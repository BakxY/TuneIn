use std::time::{Duration, Instant};

#[derive(Copy, Clone)]
pub struct DdsData {
    pub freq: f64,
    pub last_cycle: Instant,
    pub attenu: u32,
    pub on: bool,
    pub signal_data: [(f64, f64); 99],
}

impl DdsData {
    pub fn new() -> Self {
        Self {
            freq: 0.,
            last_cycle: Instant::now(),
            attenu: 0,
            on: false,
            signal_data: get_off_signal(),
        }
    }

    pub fn enable_signal(&mut self) {
        self.on = true;
        self.signal_data = get_sin_signal();
    }

    pub fn disable_signal(&mut self) {
        self.on = false;
        self.signal_data = get_off_signal();

        self.attenu = 0;
        self.freq = 0.;
    }

    pub fn apply_attenuation(&mut self) {
        for i in 1..self.signal_data.len() {
            self.signal_data[i].1 = self.signal_data[i].1 / (self.attenu as f64 + 1.);
        }
    }
}

pub fn get_off_signal() -> [(f64, f64); 99] {
    return [
        (0.000000, 0.),
        (1.010101, 0.),
        (2.020202, 0.),
        (3.030303, 0.),
        (4.040404, 0.),
        (5.050505, 0.),
        (6.060606, 0.),
        (7.070707, 0.),
        (8.080808, 0.),
        (9.090909, 0.),
        (10.101010, 0.),
        (11.111111, 0.),
        (12.121212, 0.),
        (13.131313, 0.),
        (14.141414, 0.),
        (15.151515, 0.),
        (16.161616, 0.),
        (17.171717, 0.),
        (18.181818, 0.),
        (19.191919, 0.),
        (20.202020, 0.),
        (21.212121, 0.),
        (22.222222, 0.),
        (23.232323, 0.),
        (24.242424, 0.),
        (25.252525, 0.),
        (26.262626, 0.),
        (27.272727, 0.),
        (28.282828, 0.),
        (29.292929, 0.),
        (30.303030, 0.),
        (31.313131, 0.),
        (32.323232, 0.),
        (33.333333, 0.),
        (34.343434, 0.),
        (35.353535, 0.),
        (36.363636, 0.),
        (37.373737, 0.),
        (38.383838, 0.),
        (39.393939, 0.),
        (40.404040, 0.),
        (41.414141, 0.),
        (42.424242, 0.),
        (43.434343, 0.),
        (44.444444, 0.),
        (45.454545, 0.),
        (46.464646, 0.),
        (47.474747, 0.),
        (48.484848, 0.),
        (49.494949, 0.),
        (50.505051, 0.),
        (51.515152, 0.),
        (52.525253, 0.),
        (53.535354, 0.),
        (54.545455, 0.),
        (55.555556, 0.),
        (56.565657, 0.),
        (57.575758, 0.),
        (58.585859, 0.),
        (59.595960, 0.),
        (60.606061, 0.),
        (61.616162, 0.),
        (62.626263, 0.),
        (63.636364, 0.),
        (64.646465, 0.),
        (65.656566, 0.),
        (66.666667, 0.),
        (67.676768, 0.),
        (68.686869, 0.),
        (69.696970, 0.),
        (70.707071, 0.),
        (71.717172, 0.),
        (72.727273, 0.),
        (73.737374, 0.),
        (74.747475, 0.),
        (75.757576, 0.),
        (76.767677, 0.),
        (77.777778, 0.),
        (78.787879, 0.),
        (79.797980, 0.),
        (80.808081, 0.),
        (81.818182, 0.),
        (82.828283, 0.),
        (83.838384, 0.),
        (84.848485, 0.),
        (85.858586, 0.),
        (86.868687, 0.),
        (87.878788, 0.),
        (88.888889, 0.),
        (89.898990, 0.),
        (90.909091, 0.),
        (91.919192, 0.),
        (92.929293, 0.),
        (93.939394, 0.),
        (94.949495, 0.),
        (95.959596, 0.),
        (96.969697, 0.),
        (97.979798, 0.),
        (98.989899, 0.),
    ];
}

pub fn get_sin_signal() -> [(f64, f64); 99] {
    return [
        (0.000000, 0.000000),
        (1.010101, 0.317120),
        (2.020202, 0.632962),
        (3.030303, 0.946256),
        (4.040404, 1.255740),
        (5.050505, 1.560167),
        (6.060606, 1.858312),
        (7.070707, 2.148975),
        (8.080808, 2.430984),
        (9.090909, 2.703204),
        (10.101010, 2.964540),
        (11.111111, 3.213938),
        (12.121212, 3.450395),
        (13.131313, 3.672959),
        (14.141414, 3.880732),
        (15.151515, 4.072880),
        (16.161616, 4.248627),
        (17.171717, 4.407267),
        (18.181818, 4.548160),
        (19.191919, 4.670739),
        (20.202020, 4.774511),
        (21.212121, 4.859058),
        (22.222222, 4.924039),
        (23.232323, 4.969192),
        (24.242424, 4.994337),
        (25.252525, 4.999371),
        (26.262626, 4.984274),
        (27.272727, 4.949107),
        (28.282828, 4.894012),
        (29.292929, 4.819211),
        (30.303030, 4.725004),
        (31.313131, 4.611771),
        (32.323232, 4.479969),
        (33.333333, 4.330127),
        (34.343434, 4.162849),
        (35.353535, 3.978809),
        (36.363636, 3.778748),
        (37.373737, 3.563471),
        (38.383838, 3.333845),
        (39.393939, 3.090795),
        (40.404040, 2.835299),
        (41.414141, 2.568387),
        (42.424242, 2.291133),
        (43.434343, 2.004653),
        (44.444444, 1.710101),
        (45.454545, 1.408663),
        (46.464646, 1.101553),
        (47.474747, 0.790007),
        (48.484848, 0.475280),
        (49.494949, 0.158640),
        (50.505051, -0.158640),
        (51.515152, -0.475280),
        (52.525253, -0.790007),
        (53.535354, -1.101553),
        (54.545455, -1.408663),
        (55.555556, -1.710101),
        (56.565657, -2.004653),
        (57.575758, -2.291133),
        (58.585859, -2.568387),
        (59.595960, -2.835299),
        (60.606061, -3.090795),
        (61.616162, -3.333845),
        (62.626263, -3.563471),
        (63.636364, -3.778748),
        (64.646465, -3.978809),
        (65.656566, -4.162849),
        (66.666667, -4.330127),
        (67.676768, -4.479969),
        (68.686869, -4.611771),
        (69.696970, -4.725004),
        (70.707071, -4.819211),
        (71.717172, -4.894012),
        (72.727273, -4.949107),
        (73.737374, -4.984274),
        (74.747475, -4.999371),
        (75.757576, -4.994337),
        (76.767677, -4.969192),
        (77.777778, -4.924039),
        (78.787879, -4.859058),
        (79.797980, -4.774511),
        (80.808081, -4.670739),
        (81.818182, -4.548160),
        (82.828283, -4.407267),
        (83.838384, -4.248627),
        (84.848485, -4.072880),
        (85.858586, -3.880732),
        (86.868687, -3.672959),
        (87.878788, -3.450395),
        (88.888889, -3.213938),
        (89.898990, -2.964540),
        (90.909091, -2.703204),
        (91.919192, -2.430984),
        (92.929293, -2.148975),
        (93.939394, -1.858312),
        (94.949495, -1.560167),
        (95.959596, -1.255740),
        (96.969697, -0.946256),
        (97.979798, -0.632962),
        (98.989899, -0.317120),
    ];
}

const MIN_FREQ: f64 = 4.08796875;
const MAX_FREQ: f64 = 6272.0;

const MIN_DELAY: Duration = Duration::from_millis(1);
const MAX_DELAY: Duration = Duration::from_millis(100);

pub fn convert_freq_to_tick_delay(freq: f64) -> Duration {
    if freq >= MAX_FREQ {
        return MAX_DELAY;
    } else if freq <= MIN_FREQ {
        return MIN_DELAY;
    } else {
        return MAX_DELAY
            - Duration::mul_f64(
                MAX_DELAY - MIN_DELAY,
                (freq - MIN_FREQ) / (MAX_FREQ - MIN_FREQ),
            );
    }
}
